https://www.gnu.org/software/wget/ Wget < Formula
  homepage "https://www.gnu.org/software/wget/"
  url "https://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz"
  sha256 "52126be8cf1bddd7536886e74c053ad7d0ed2aa89b4b630f76785bac21695fcd"

  def install
    system "./configure", "--prefix=#{prefix}"
    system "make", "install"
  end
end

https://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"https://raw.githubusercontent.com/Homebrew/install/HEAD/install.shUsage:  cmc [ -c HOST | -x HOST ]
        cmc [ -l | -X ]
        cmc -h

ControlMaster Controller - Eases management of SSH ControlMaster connections

Options:
    -h      show this help message and exit
    -c HOST check HOST ControlMaster connection status (may be specified more
            than once)
    -d      print debug information
    -l      list all active ControlMaster connection sockets
    -x HOST exit ControlMaster session (may be specified more than once)
    -X      exit all ControlMaster connections with sockets

Notes:
    - Any unused sockets in  #cc-dev-workprograms<emoji>âŽµ<category>:âŽµ<name>
âœ” Which CI providers are you configuring?: Travis CI
Enter the following values (leave empty to omit):
âœ” Personal access token for GitHub: ***************
âœ” Base url of the GitHub instance: https://github.com
âœ” Personal access token for Travis CI: ***************
âœ” Base url of the Travis CI instance: https://travis-ci.com
âœ” Travis CI organization name: actions-importer-labs
Environment variables successfullyhttps://github.comhttps://travis-ci.com"stay"-# Perform a production migration of a GitLab pipeline

In this lab, you will use the `migrate` command to convert a GitLab pipeline and open a pull request with the equivalent Actions workflow.

## Prerequisites

1. Followed the steps [here](./readme.md#configure-your-codespace) to set up your GitHub Codespaces environment and start a GitLab server.
2. Completed the [configure lab](./1-configure.md#configuring-credentials).
3. Completed the [dry-run lab](./4-dry-run.md).

## Performing a migration

Answer the following questions before running a `migrate` command:

1. What project do you want to migrate?
    - __rails-example__
2. What is the namespace for that project?
    - __actions-importer__
3. Where do you want to store the logs?
    - __tmp/migrate__
4. What is the URL for the GitHub repository to add the workflow to?
    - __this repository__. The URL should should follow the pattern <https://github.com/:owner/:repo> with `:owner` and `:repo` replaced with your values.

### Steps

1. Run the following `migrate` command in the codespace terminal:

    ```bash
    gh actions-importer migrate gitlab --target-url https://github.com/:owner/:repo --output-dir tmp/migrate --namespace actions-importer --project rails-example
    ```

2. The command will write the URL to the pull request that was created when the command succeeds.

    ```console
    $ gh actions-importer migrate gitlab --target-url https://github.com/:owner/:repo --output-dir tmp/migrate
    [2022-08-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20220916-014033.log'
    [2022-08-20 22:08:20] Pull request: 'https://github.com/:owner/:repo/pull/1'
    ```

3. Open the generated pull request in a new browser tab.

### Inspect the pull request

The first thing to notice about the pull request is that there is a list of manual steps to complete.

Next, you can inspect the "Files changed" in this pull request and see the converted workflow that is being added. Any additional changes or code reviews that were needed should be done in this pull request.

Finally, you can merge the pull request once your review has completed. You can then view the workflow running by selecting the "Actions" menu in the top navigation bar in GitHub.

![img](https://user-images.githubusercontent.com/18723510/184960870-590b1a28-422f-4350-9ec0-0423bf7ad445.png)

At this point, the migration has completed and you have successfully migrated a GitLab pipeline to Actions!

### Next Lab

This concludes all labs for migrating GitLab pipelines to Actions with GitHub Actions Importer!-configure.md#configuring-credentialshttps://github.com/:owner/:repo-dry-run.md2022-08-20 22:08:2020220916-0140https://github.com/:owner/:repohttps://github.com/:owner/:repo/pull/1https://user-images.githubusercontent.com/18723510/184960870-590b1a28-422f-4350-9ec0-0423bf7ad445.png# Using custom transformers to customize GitHub Actions Importer's behavior

In this lab we will build upon the `dry-run` command to override GitHub Actions Importer's default behavior and customize the converted workflow using "custom transformers". Custom transformers can be used to:

1. Convert items that are not automatically converted.
2. Convert items that were automatically converted using different actions.
3. Convert environment variable values differently.
4. Convert references to runners to use a different runner name in Actions.

## Prerequisites

1. Followed the steps [here](./readme.md#configure-your-codespace) to set up your GitHub Codespaces environment and bootstrap an Azure DevOps project.
2. Completed the [configure lab](./1-configure.md#configuring-credentials).
3. Completed the [audit lab](./2-audit.md).
4. Completed the [dry-run lab](./4-dry-run.md).

## Perform a dry run

You will perform a dry-run for a pipeline in the bootstrapped Azure DevOps project. Answer the following questions before running this command:

1. What is the id of the pipeline to convert?
    - __:pipeline_id__. This id can be found by:
      - Navigating to the build pipelines in the bootstrapped Azure DevOps project <https://dev.azure.com/:organization/:project/_build>
      - Selecting the pipeline with the name "custom-transformer-example"
      - Inspecting the URL to locate the pipeline id <https://dev.azure.com/:organization/:project/_build?definitionId=:pipeline_id>

2. Where do you want to store the result?
    - __tmp/dry-run__. This can be any path within the working directory from which GitHub Actions Importer commands are executed.

### Steps

1. Navigate to the codespace terminal
2. Run the following command from the root directory:

    ```bash
    gh actions-importer dry-run azure-devops pipeline --pipeline-id :pipeline_id --output-dir tmp/dry-run
    ```

3. The command will list all the files written to disk when the command succeeds.
4. View the converted workflow:
    - Find `tmp/dry-run/pipelines/lab-testing/pipelines/custom-transformer-example/.github/workflows` in the file explorer pane in your codespace.
    - Click `custom-transformer-example.yml` to open.

The converted workflow that is generated can be seen below:

<details>
  <summary><em>Converted workflow ðŸ‘‡</em></summary>

```yaml
name: actions-importer-bootstrap/pipelines/custom-transformer-example
on:
  push:
    branches:
    - "*"
env:
  BUILDCONFIGURATION: Release
  BuildParameters_RESTOREBUILDPROJECTS: "**/*.csproj"
jobs:
  Job_1:
    name: Agent job 1
    runs-on:
      - self-hosted
      - mechamachine
    steps:
    - name: checkout
      uses: actions/checkout@v2
    - uses: actions/checkout@v2
    - name: Use Node 10.16.3
      uses: actions/setup-node@v2
      with:
        node-version: 10.16.3
    - name: Restore
      run: dotnet restore ${{ env.BuildParameters_RESTOREBUILDPROJECTS }}
    - name: Build
      run: dotnet build ${{ env.BuildParameters_RESTOREBUILDPROJECTS }} --configuration ${{ env.BUILDCONFIGURATION }}
```

</details>

_Note_: You can refer to the previous [lab](./4-dry-run.md) to learn about the fundamentals of the `dry-run` command.

## Custom transformers for build steps

You can use custom transformers to override GitHub Actions Importer's default behavior. In this scenario, you may want to override the behavior for converting `DotnetCoreCLI@2` tasks to support parameters that are glob patterns. Answer the following questions before writing a custom transformer:

1. What is the "identifier" of the step to customize?
    - __DotnetCoreCLI@2__

2. What is the desired Actions syntax to use instead?
      - After some research, you have determined that the following script will provide the desired functionality:

      ```yaml
        - run: shopt -s globstar; for f in ./**/*.csproj; do dotnet build $f --configuration ${{ env.BUILDCONFIGURATION }} ; done
          shell: bash
      ```

Now you can begin to write the custom transformer. Custom transformers use a DSL built on top of Ruby and should be defined in a file with the `.rb` file extension. You can create this file by running the following command in your codespace terminal:

```bash
touch transformers.rb && code transformers.rb
```

To build this custom transformer, you first need to inspect the `item` keyword to programmatically obtain the projects, command, and arguments to use in the `DotNetCoreCLI@2` step.

To do this, you will print `item` to the console. You can achieve this by adding the following custom transformer to `transformers.rb`:

```ruby
transform "DotNetCoreCLI@2" do |item|
  puts "This is the item: #{item}"
end
```

The `transform` method can use any valid ruby syntax and should return a `Hash` that represents the YAML that should be generated for a given step. GitHub Actions Importer will use this method to convert a step with the provided identifier and will use the `item` parameter for the original values configured in Azure DevOps.

Now, you can perform a `dry-run` command with the `--custom-transformers` CLI option. The output of the `dry-run` command should look similar to this:

```console
$ gh actions-importer dry-run azure-devops pipeline --pipeline-id 6 --output-dir tmp/dry-run --custom-transformers transformers.rb
[2022-09-20 18:39:50] Logs: 'tmp/dry-run/log/actions-importer-20220920-183950.log'         
This is the item: {"command"=>"restore", "projects"=>"$(BuildParameters.RESTOREBUILDPROJECTS)"}
This is the item: {"projects"=>"$(BuildParameters.RESTOREBUILDPROJECTS)", "arguments"=>"--configuration $(BUILDCONFIGURATION)"}
[2022-09-20 18:39:51] Output file(s):
[2022-09-20 18:39:51]   tmp/dry-run/pipelines/lab-testing/pipelines/custom-transformer-example/.github/workflows/custom-transformer-example.yml
```

In the above command you will see two instances of `item` printed to the console. This is because there are two `DotNetCoreCLI@2` steps in the pipeline. Each item listed above represents each `DotNetCoreCLI@2` step in the order that they are defined in the pipeline.-audit.mdhttps://dev.azure.com/:organization/:project/_buildhttps://dev.azure.com/:organization/:project/_build?definitionId=:pipeline_id1transformers.rbenv.BUILDCONFIGURATION62022-09-20 18:39:5020220920-18392022-09-20 18:39:51 Job count: **84**
- Pipeline count: **32**

- Execution time

  - Total: **82 minutes**
  - Median: **0 minutes**
  - P90: **2 minutes**
  - Min: **0 minutes**
  - Max: **4 minutes**

- Queue time

  - Median: **0 minutes**
  - P90: **1 minutes**
  - Min: **0 minutes**
  - Max: **5 minutes**

- Concurrent jobs

  - Median: **0**
  - P90: **0**
  - Min: **0**
  - Max: **5**gh actions-importer forecast azure-devops --output-dir tmp/forecast --source-file-path azure_devops/bootstrap/jobs.json
[2022-08-20 22:08:20] Logs: 'tmp/forecast/log/actions-importer-20220916-021004.log'
[2022-08-20 22:08:20] Forecasting 'http://dev.azure.com/mona/actions-bootstrap/_build'
[2022-08-20 22:08:20] Outfile file(s):
[2022-08-20 22:08:20]   ./tmp/forec20220916-0210http://dev.azure.com/mona/actions-bootstrap/_build$ gh actions-importer forecast azure-devops -h
Options:
  -g, --azure-devops-organization <azure-devops-organization>  The Azure DevOps organization name.
  -p, --azure-devops-project <azure-devops-project>            The Azure DevOps project name.
  -u, --azure-devops-instance-url <azure-devops-instance-url>  The URL of the Azure DevOps instance.
  -t, --azure-devops-access-token <azure-devops-access-token>  Access token for the Azure DevOps instance.
  --source-file-path <source-file-path>                        The file path(s) to existing jobs data.
  -o, --output-dir <output-dir> (REQUIRED)                     The location for any output files.
  --start-date <start-date>                                    The start date of the forecast analysis in YYYY-MM-DD format. [default:
                                                               10/31/2022 8:35:17 AM]
  --time-slice <time-slice>                                    The time slice in seconds to use for computing concurrency metrics.
                                                               [default: 60]
  --credentials-file <credentials-file>                        The file containing the credentials to use.
  --no-telemetry                                               Boolean value to disallow telemetry.
  --no-ssl-verify                                              Disable ssl certificate verification.
  --no-http-cache                                              Disable caching of http responses.
  -?, -h, --help              10/31/2022 8:35:17 AMkingdom hearts # Using custom transformers to customize GitHub Actions Importer's behavior

In this lab we will build upon the `dry-run` command to override GitHub Actions Importer's default behavior and customize the converted workflow using "custom transformers". Custom transformers can be used to:

1. Convert items that are not automatically converted.
2. Convert items that were automatically converted using different actions.
3. Convert environment variable values differently.
4. Convert references to runners to use a different runner name in Actions.

## Prerequisites

1. Followed the steps [here](./readme.md#configure-your-codespace) to set up your GitHub Codespaces environment and bootstrap an Azure DevOps project.
2. Completed the [configure lab](./1-configure.md#configuring-credentials).
3. Completed the [audit lab](./2-audit.md).
4. Completed the [dry-run lab](./4-dry-run.md).

## Perform a dry run

You will perform a dry-run for a pipeline in the bootstrapped Azure DevOps project. Answer the following questions before running this command:

1. What is the id of the pipeline to convert?
    - __:pipeline_id__. This id can be found by:
      - Navigating to the build pipelines in the bootstrapped Azure DevOps project <https://dev.azure.com/:organization/:project/_build>
      - Selecting the pipeline with the name "custom-transformer-example"
      - Inspecting the URL to locate the pipeline id <https://dev.azure.com/:organization/:project/_build?definitionId=:pipeline_id>

2. Where do you want to store the result?
    - __tmp/dry-run__. This can be any path within the working directory from which GitHub Actions Importer commands are executed.

### Steps

1. Navigate to the codespace terminal
2. Run the following command from the root directory:

    ```bash
    gh actions-importer dry-run azure-devops pipeline --pipeline-id :pipeline_id --output-dir tmp/dry-run
    ```

3. The command will list all the files written to disk when the command succeeds.
4. View the converted workflow:
    - Find `tmp/dry-run/pipelines/lab-testing/pipelines/custom-transformer-example/.github/workflows` in the file explorer pane in your codespace.
    - Click `custom-transformer-example.yml` to open.

The converted workflow that is generated can be seen below:

<details>
  <summary><em>Converted workflow ðŸ‘‡</em></summary>

```yaml
name: actions-importer-bootstrap/pipelines/custom-transformer-example
on:
  push:
    branches:
    - "*"
env:
  BUILDCONFIGURATION: Release
  BuildParameters_RESTOREBUILDPROJECTS: "**/*.csproj"
jobs:
  Job_1:
    name: Agent job 1
    runs-on:
      - self-hosted
      - mechamachine
    steps:
    - name: checkout
      uses: actions/checkout@v2
    - uses: actions/checkout@v2
    - name: Use Node 10.16.3
      uses: actions/setup-node@v2
      with:
        node-version: 10.16.3
    - name: Restore
      run: dotnet restore ${{ env.BuildParameters_RESTOREBUILDPROJECTS }}
    - name: Build
      run: dotnet build ${{ env.BuildParameters_RESTOREBUILDPROJECTS }} --configuration ${{ env.BUILDCONFIGURATION }}
```

</details>

_Note_: You can refer to the previous [lab](./4-dry-run.md) to learn about the fundamentals of the `dry-run` command.

## Custom transformers for build steps

You can use custom transformers to override GitHub Actions Importer's default behavior. In this scenario, you may want to override the behavior for converting `DotnetCoreCLI@2` tasks to support parameters that are glob patterns. Answer the following questions before writing a custom transformer:

1. What is the "identifier" of the step to customize?
    - __DotnetCoreCLI@2__

2. What is the desired Actions syntax to use instead?
      - After some research, you have determined that the following script will provide the desired functionality:

      ```yaml
        - run: shopt -s globstar; for f in ./**/*.csproj; do dotnet build $f --configuration ${{ env.BUILDCONFIGURATION }} ; done
          shell: bash
      ```

Now you can begin to write the custom transformer. Custom transformers use a DSL built on top of Ruby and should be defined in a file with the `.rb` file extension. You can create this file by running the following command in your codespace terminal:

```bash
touch transformers.rb && code transformers.rb
```

To build this custom transformer, you first need to inspect the `item` keyword to programmatically obtain the projects, command, and arguments to use in the `DotNetCoreCLI@2` step.

To do this, you will print `item` to the console. You can achieve this by adding the following custom transformer to `transformers.rb`:

```ruby
transform "DotNetCoreCLI@2" do |item|
  puts "This is the item: #{item}"
end
```

The `transform` method can use any valid ruby syntax and should return a `Hash` that represents the YAML that should be generated for a given step. GitHub Actions Importer will use this method to convert a step with the provided identifier and will use the `item` parameter for the original values configured in Azure DevOps.

Now, you can perform a `dry-run` command with the `--custom-transformers` CLI option. The output of the `dry-run` command should look similar to this:

```console
$ gh actions-importer dry-run azure-devops pipeline --pipeline-id 6 --output-dir tmp/dry-run --custom-transformers transformers.rb
[2022-09-20 18:39:50] Logs: 'tmp/dry-run/log/actions-importer-20220920-183950.log'         
This is the item: {"command"=>"restore", "projects"=>"$(BuildParameters.RESTOREBUILDPROJECTS)"}
This is the item: {"projects"=>"$(BuildParameters.RESTOREBUILDPROJECTS)", "arguments"=>"--configuration $(BUILDCONFIGURATION)"}
[2022-09-20 18:39:51] Output file(s):
[2022-09-20 18:39:51]   tmp/dry-run/pipelines/lab-testing/pipelines/custom-transformer-example/.github/workflows/custom-transformer-example.yml
```

In the above command you will see two instances of `item` printed to the console. This is because there are two `DotNetCoreCLI@2` steps in the pipeline. Each item listed above represents each `DotNetCoreCLI@2` step in the order that they are defined in the pipeline.-configure.md#configuring-credentials-audit.md-dry-run.mdhttps://dev.azure.com/:organization/:project/_buildhttps://dev.azure.com/:organization/:project/_build?definitionId=:pipeline_id1env.BUILDCONFIGURATIONtransformers.rb2022-09-20 18:39:5062022-09-20 18:39:5120220920-1839 Job count: **84**
- Pipeline count: **32**

- Execution time

  - Total: **82 minutes**
  - Median: **0 minutes**
  - P90: **2 minutes**
  - Min: **0 minutes**
  - Max: **4 minutes**

- Queue time

  - Median: **0 minutes**
  - P90: **1 minutes**
  - Min: **0 minutes**
  - Max: **5 minutes**

- Concurrent jobs

  - Median: **0**
  - P90: **0**
  - Min: **0**
  - Max: **5**gh actions-importer forecast azure-devops --output-dir tmp/forecast --source-file-path azure_devops/bootstrap/jobs.json
[2022-08-20 22:08:20] Logs: 'tmp/forecast/log/actions-importer-20220916-021004.log'
[2022-08-20 22:08:20] Forecasting 'http://dev.azure.com/mona/actions-bootstrap/_build'
[2022-08-20 22:08:20] Outfile file(s):
[2022-08-20 22:08:20]   ./tmp/forec2022-08-20 22:08:2020220916-0210$ gh actions-importer forecast azure-devops -h
Options:
  -g, --azure-devops-organization <azure-devops-organization>  The Azure DevOps organization name.
  -p, --azure-devops-project <azure-devops-project>            The Azure DevOps project name.
  -u, --azure-devops-instance-url <azure-devops-instance-url>  The URL of the Azure DevOps instance.
  -t, --azure-devops-access-token <azure-devops-access-token>  Access token for the Azure DevOps instance.
  --source-file-path <source-file-path>                        The file path(s) to existing jobs data.
  -o, --output-dir <output-dir> (REQUIRED)                     The location for any output files.
  --start-date <start-date>                                    The start date of the forecast analysis in YYYY-MM-DD format. [default:
                                                               10/31/2022 8:35:17 AM]
  --time-slice <time-slice>                                    The time slice in seconds to use for computing concurrency metrics.
                                                               [default: 60]
  --credentials-file <credentials-file>                        The file containing the credentials to use.
  --no-telemetry                                               Boolean value to disallow telemetry.
  --no-ssl-verify                                              Disable ssl certificate verification.
  --no-http-cache                                              Disable caching of http responses.
  -?, -h, --help              http://dev.azure.com/mona/actions-bootstrap/_build**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.
Start a new codespace

Click the Code button on your repository's landing page.
Click the Codespaces tab.
Click Create codespaces on main to create the codespace.
After the codespace has initialized there will be a terminal present.
Verify the GitHub Actions Importer CLI is installed and working. More information on the GitHub Actions Importer extension for the official GitHub CLI can be found here.

Run the following command in the codespace terminal:

gh actions-importer version
Verify the output is similar to below.

$ gh actions-importer version
gh version 2.14.3 (2022-07-26)
gh actions-importer        github/gh-actions-importer v0.1.12
actions-importer/cli       unknown
If gh actions-importer version did not produce similar output, please refer to the troubleshooting section.

Bootstrap a GitLab server
Execute the GitLab setup script that will start a container with GitLab running inside of it. The script should be executed when starting a new codespace or restarting an existing one.

Run the following command from the codespace terminal:

./gitlab/bootstrap/setup.sh
After some time, a pop-up box should appear with a link to the URL for your GitLab server.

You can also access the URL by going to the Ports tab in your terminal. Right-click the URL listed under the Local Address and click the Open in Browser tab.

Open the GitLab server in your browser and use the following credentials to authenticate:

Username: root
Password: actions-importer-labs!
Once authenticated, you should see a GitLab server with a few predefined pipelines in the actions-importer group.

Labs for GitLab
Perform the following labs to learn more about Actions migrations with GitHub Actions Importer:

Configure credentials for GitHub Actions Importer
Perform an audit on GitLab pipelines
Forecast potential build runner usage
Perform a dry-run migration of a GitLab pipeline
Use custom transformers to customize GitHub Actions Importer's behavior
Perform a production migration of a GitLab pipeline
Troubleshoot the GitHub Actions Importer CLI
The CLI extension for GitHub Actions Importer can be manually installed by following these steps:

Verify you are in the codespace terminal

Run this command from within the codespace terminal:

gh extension install github/gh-actions-importer
Verify the result of the install contains:

$ gh extension install github/gh-actions-importer
âœ“ Installed extension github/gh-actions-importer
Verify GitHub Actions Importer CLI extension is installed and working by running the following command from the codespace terminal:

gh actions-importer version
**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.https://github.com/bradford80USA/unamed/actions/workflows/azure-container-webapp.yml1998350Program Overview
Privileges of Membership
Over 1300 organizations and individuals parti-
cipate in the JCP program. While there are no
obligatory duties, members have the opportunity
to influence the evolution of Java technology
through the development of Java Specification
Requests (JSR).
Members can license their Java specifications
under a variety of licenses, including open source
options. Anyone must be able to create an indepen-
dent implementation as long as they license and pass the
TCK to ensure compatibility. Members must also
make the option available to license the TCK and
RI separately. In addition, individuals, educational
organizations, and qualified nonprofits must have
access to the TCKs free of charge.
Successful Members:
â€¢ Review proposed JSRs and drafts
â€¢ Submit JSRs
â€¢ Nominate themselves or others to serve
on Expert Groups, which create or revise
specifications
â€¢ Build independent implementations
â€¢ Vote on EC membership ballots
â€¢ Nominate themselves for an EC seat
Members of an Expert Group may also:
â€¢ Serve as the Specification Lead of an
Expert Group
â€¢ Select others to join their Expert Group
â€¢ Use feedback from members and the public
to improve the quality of a specification
â€¢ Complete a specification, its RI, and its
associated TCK
â€¢ Maintain a specification after it is written
How to Become a Member
A person or organization can become a member
by signing the Java Specification Participation
Agreement (JSPA). This agreement between an
organization or individual and Oracle establishes
each memberâ€™s rights and obligations when partici-
pating in the JCP program. To cover costs, the JSPA
charges a nominal fee for commercial entities, but it
is free for Java User Groups and individuals.
The Java Specification Review Process
Currently, over 350 JSRs are in development.
A specification follows four major steps as it
progresses through the process, as shown in
the timeline.
1. INITIATION: A specification is initiated by one or
more members and approved for development
by the Executive Committee.
2. EARLY DRAFT: A group of experts is formed to
draft the specification for the public, community
and the Executive Committee to review. The
Expert Group uses feedback from the review to
revise the specification.
3. PUBLIC DRAFT: The draft is posted on the Internet
for a second review by the public. The Expert
Group uses the feedback to refine the document.
The Executive Committee decides if the draft
should proceed to the next step. The Specification
Lead ensures that the RI and its associated TCK
are completed before sending the specification to
the Executive Committee for final approval.
Java Community Process Program Overview
The Java Community Process (JCP) program is the formalization of the open, inclusive
process that has been used since 1998 to develop and revise Java technology specifications,
reference implementations (RI), and technology compatibility kits (TCK). Jav130010/31/2022 8:35:17 AM1300https://github.com/bradford80USA/unamed/actions/workflows/azure-container-webapp.yml1998350Program3501998kingdom hearts  Job count: **84**
- Pipeline count: **32**

- Execution time

  - Total: **82 minutes**
  - Median: **0 minutes**
  - P90: **2 minutes**
  - Min: **0 minutes**
  - Max: **4 minutes**

- Queue time

  - Median: **0 minutes**
  - P90: **1 minutes**
  - Min: **0 minutes**
  - Max: **5 minutes**

- Concurrent jobsStart a new codespace

Click the Code button on your repository's landing page.
Click the Codespaces tab.
Click Create codespaces on main to create the codespace.
After the codespace has initialized there will be a terminal present.
Verify the GitHub Actions Importer CLI is installed and working. More information on the GitHub Actions Importer extension for the official GitHub CLI can be found here.

Run the following command in the codespace terminal:

gh actions-importer version
Verify the output is similar to below.

$ gh actions-importer version
gh version 2.14.3 (2022-07-26)
gh actions-importer        github/gh-actions-importer v0.1.12
actions-importer/cli       unknown
If gh actions-importer version did not produce similar output, please refer to the troubleshooting section.

Bootstrap a GitLab server
Execute the GitLab setup script that will start a container with GitLab running inside of it. The script should be executed when starting a new codespace or restarting an existing one.

Run the following command from the codespace terminal:

./gitlab/bootstrap/setup.sh
After some time, a pop-up box should appear with a link to the URL for your GitLab server.

You can also access the URL by going to the Ports tab in your terminal. Right-click the URL listed under the Local Address and click the Open in Browser tab.

Open the GitLab server in your browser and use the following credentials to authenticate:

Username: root
Password: actions-importer-labs!
Once authenticated, you should see a GitLab server with a few predefined pipelines in the actions-importer group.

Labs for GitLab
Perform the following labs to learn more about Actions migrations with GitHub Actions Importer:

Configure credentials for GitHub Actions Importer
Perform an audit on GitLab pipelines
Forecast potential build runner usage
Perform a dry-run migration of a GitLab pipeline
Use custom transformers to customize GitHub Actions Importer's behavior
Perform a production migration of a GitLab pipeline
Troubleshoot the GitHub Actions Importer CLI
The CLI extension for GitHub Actions Importer can be manually installed by following these steps:

Verify you are in the codespace terminal

Run this command from within the codespace terminal:

gh extension install github/gh-actions-importer
Verify the result of the install contains:

$ gh extension install github/gh-actions-importer
âœ“ Installed extension github/gh-actions-importer
Verify GitHub Actions Importer CLI extension is installed and working by running the following command from the codespace terminal:

gh actions-importer version

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.https://github.com/bradford80USA/unamed/actions/workflows/azure-container-webapp.yml1998350Program Overview
Privileges of Membership
Over 1300 organizations and individuals parti-
cipate in the JCP program. While there are no
obligatory duties, members have the opportunity
to influence the evolution of Java technology
through the development of Java Specification
Requests (JSR).
Members can license their Java specifications
under a variety of licenses, including open source
options. Anyone must be able to create an indepen-
dent implementation as long as they license and pass the
TCK to ensure compatibility. Members must also
make the option available to license the TCK and
RI separately. In addition, individuals, educational
organizations, and qualified nonprofits must have
access to the TCKs free of charge.
Successful Members:
â€¢ Review proposed JSRs and drafts
â€¢ Submit JSRs
â€¢ Nominate themselves or others to serve
on Expert Groups, which create or revise
specifications
â€¢ Build independent implementations
â€¢ Vote on EC membership ballots
â€¢ Nominate themselves for an EC seat
Members of an Expert Group may also:
â€¢ Serve as the Specification Lead of an
Expert Group
â€¢ Select others to join their Expert Group
â€¢ Use feedback from members and the public
to improve the quality of a specification
â€¢ Complete a specification, its RI, and its
associated TCK
â€¢ Maintain a specification after it is written
How to Become a Member
A person or organization can become a member
by signing the Java Specification Participation
Agreement (JSPA). This agreement between an
organization or individual and Oracle establishes
each memberâ€™s rights and obligations when partici-
pating in the JCP program. To cover costs, the JSPA
charges a nominal fee for commercial entities, but it
is free for Java User Groups and individuals.
The Java Specification Review Process
Currently, over 350 JSRs are in development.
A specification follows four major steps as it
progresses through the process, as shown in
the timeline.
1. INITIATION: A specification is initiated by one or
more members and approved for development
by the Executive Committee.
2. EARLY DRAFT: A group of experts is formed to
draft the specification for the public, community
and the Executive Committee to review. The
Expert Group uses feedback from the review to
revise the specification.
3. PUBLIC DRAFT: The draft is posted on the Internet
for a second review by the public. The Expert
Group uses the feedback to refine the document.
The Executive Committee decides if the draft
should proceed to the next step. The Specification
Lead ensures that the RI and its associated TCK
are completed before sending the specification to
the Executive Committee for final approval.
Java Community Process Program Overview
The Java Community Process (JCP) program is the formalization of the open, inclusive
process that has been used since 1998 to develop and revise Java technology specifications,
reference implementations (RI), and technology compatibility kits (TCK). Jav1300Program Overview
Privileges of Membership
Over 1300 organizations and individuals parti-
cipate in the JCP program. While there are no
obligatory duties, members have the opportunity
to influence the evolution of Java technology
through the development of Java Specification
Requests (JSR).
Members can license their Java specifications
under a variety of licenses, including open source
options. Anyone must be able to create an indepen-
dent implementation as long as they license and pass the
TCK to ensure compatibility. Members must also
make the option available to license the TCK and
RI separately. In addition, individuals, educational
organizations, and qualified nonprofits must have
access to the TCKs free of charge.
Successful Members:
â€¢ Review proposed JSRs and drafts
â€¢ Submit JSRs
â€¢ Nominate themselves or others to serve
on Expert Groups, which create or revise
specifications
â€¢ Build independent implementations
â€¢ Vote on EC membership ballots
â€¢ Nominate themselves for an EC seat
Members of an Expert Group may also:
â€¢ Serve as the Specification Lead of an
Expert Group
â€¢ Select others to join their Expert Group
â€¢ Use feedback from members and the public
to improve the quality of a specification
â€¢ Complete a specification, its RI, and its
associated TCK
â€¢ Maintain a specification after it is written
How to Become a Member
A person or organization can become a member
by signing the Java Specification Participation
Agreement (JSPA). This agreement between an
organization or individual and Oracle establishes
each memberâ€™s rights and obligations when partici-
pating in the JCP program. To cover costs, the JSPA
charges a nominal fee for commercial entities, but it
is free for Java User Groups and individuals.
The Java Specification Review Process
Currently, over 350 JSRs are in development.
A specification follows four major steps as it
progresses through the process, as shown in
the timeline.
1. INITIATION: A specification is initiated by one or
more members and approved for development
by the Executive Committee.
2. EARLY DRAFT: A group of experts is formed to
draft the specification for the public, community
and the Executive Committee to review. The
Expert Group uses feedback from the review to
revise the specification.
3. PUBLIC DRAFT: The draft is posted on the Internet
for a second review by the public. The Expert
Group uses the feedback to refine the document.
The Executive Committee decides if the draft
should proceed to the next step. The Specification
Lead ensures that the RI and its associated TCK
are completed before sending the specification to
the Executive Committee for final approval.
Java Community Process Program Overview
The Java Community Process (JCP) program is the formalization of the open, inclusive
process that has been used since 1998 to develop and revise Java technology specifications,
reference implementations (RI), and technology compatibility kits (TCK). Jav
Start a new codespace.

Click the Code button on your repository's landing page.
Click the Codespaces tab.
Click Create codespaces on main to create the codespace.
After the codespace has initialized there will be a terminal present.
Verify the GitHub Actions Importer CLI is installed and working. More information on the GitHub Actions Importer extension for the official GitHub CLI can be found here.

Run the following command in the codespace terminal:

gh actions-importer version
Verify the output is similar to below.

$ gh actions-importer version
gh version 2.14.3 (2022-07-26)
gh actions-importer        github/gh-actions-importer v0.1.12
actions-importer/cli       unknown
If gh actions-importer version did not produce similar output, please refer to the troubleshooting section.

Bootstrap your Azure DevOps organization
Create an Azure DevOps personal access token (PAT):

Navigate to your existing organization (https://dev.azure.com/:organization) in your browser.
In the top right corner of the screen, click User settings.
Click Personal access tokens.
Select + New Token
Name your token, select the organization where you want to use the token, and set your token to automatically expire after a set number of days.
Select the following scopes (you may need to select Show all scopes at the bottom of the page to reveal all scopes):
Agents Pool: Read
Build: Read & execute
Code: Read & write
Project and Team: Read, write, & manage
Release: Read
Service Connections: Read
Task Groups: Read
Variable Groups: Read
Click Create.
Copy the generated API token and save it in a safe location.
Execute the Azure DevOps setup script that will create a new Azure DevOps project in your organization to be used in the following labs. This script should only be run once.

Run the following command from the codespace terminal, replacing the values accordingly:

:organization: the name of your existing Azure DevOps organization
:project: the name of the project to be created in your Azure DevOps organization
:access_token: the PAT created in step 1 above
./azure_devops/bootstrap/setup --organization :organization --project :project --access-token :access-token
Open the newly created Azure DevOps project in your browser (https://dev.azure.com/:organization/:project)

Once authenticated, you will see an Azure DevOps project with a few predefined pipelines.
Labs for Azure DevOps
Perform the following labs to learn how to migrate Azure DevOps pipelines to GitHub Actions using GitHub Actions Importer:

Configure credentials for GitHub Actions Importer
Perform an audit of an Azure DevOps project
Forecast potential build runner usage
Perform a dry-run migration of an Azure DevOps pipeline
Use custom transformers to customize GitHub Actions Importer's behavior
Perform a production migration of a Azure DevOps pipeline
Troubleshoot the GitHub Actions Importer CLI
The CLI extension for GitHub Actions Importer can be manually installed by following these steps:

Verify you are in the codespace terminal

Run this command from within the codespace terminal:

gh extension install github/gh-actions-importer
Verify the result of the install contains:

$ gh extension install github/gh-actions-importer
âœ“ Installed extension github/gh-actions-importer
Verify GitHub Actions Importer CLI extension is installed and working by running the following command from the codespace terminal:

gh actions-importer versionhttps://dev.azure.com/:organizationhttps://dev.azure.com/:organization/:project1{"$id":"1","innerException":null,"message":"A potentially dangerous Request.Path value was detected from the client (:).","typeName":"System.Web.HttpException, System.Web","typeKey":"HttpException","errorCode":0,"eventId":0}


    Request.Pathkingdom hearts 

  - Median: **0**
  - P90: **0**
  - Min: **0**
  - Max: **5**gh actions-importer forecast azure-devops --output-dir tmp/forecast --source-file-path azure_devops/bootstrap/jobs.json
[2022-08-20 22:08:20] Logs: 'tmp/forecast/log/actions-importer-20220916-021004.log'
[2022-08-20 22:08:20] Forecasting 'http://dev.azure.com/mona/actions-bootstrap/_build'
[2022-08-20 22:08:20] Outfile file(s):
[2022-08-20 22:08:20]   ./tmp/forec2022-08-20 22:08:2020220916-0210http://dev.azure.com/mona/actions-bootstrap/_build$ gh actions-importer forecast azure-devops -h
Options:
  -g, --azure-devops-organization <azure-devops-organization>  The Azure DevOps organization name.
  -p, --azure-devops-project <azure-devops-project>            The Azure DevOps project name.
  -u, --azure-devops-instance-url <azure-devops-instance-url>  The URL of the Azure DevOps instance.
  -t, --azure-devops-access-token <azure-devops-access-token>  Access token for the Azure DevOps instance.
  --source-file-path <source-file-path>                        The file path(s) to existing jobs data.
  -o, --output-dir <output-dir> (REQUIRED)                     The location for any output files.
  --start-date <start-date>                                    The start date of the forecast analysis in YYYY-MM-DD format. [default:
                                                               10/31/2022 8:35:17 AM]
  --time-slice <time-slice>                                    The time slice in seconds to use for computing concurrency metrics.
                                                               [default: 60]
  --credentials-file <credentials-file>                        The file containing the credentials to use.
  --no-telemetry                                               Boolean value to disallow telemetry.
  --no-ssl-verify                                              Disable ssl certificate verification.
  --no-http-cache                                              Disable caching of http responses.
  -?, -h, --help              10/31/2022 8:35:17 AM**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.
Start a new codespace

Click the Code button on your repository's landing page.
Click the Codespaces tab.
Click Create codespaces on main to create the codespace.
After the codespace has initialized there will be a terminal present.
Verify the GitHub Actions Importer CLI is installed and working. More information on the GitHub Actions Importer extension for the official GitHub CLI can be found here.

Run the following command in the codespace terminal:

gh actions-importer version
Verify the output is similar to below.

$ gh actions-importer version
gh version 2.14.3 (2022-07-26)
gh actions-importer        github/gh-actions-importer v0.1.12
actions-importer/cli       unknown
If gh actions-importer version did not produce similar output, please refer to the troubleshooting section.

Bootstrap a GitLab server
Execute the GitLab setup script that will start a container with GitLab running inside of it. The script should be executed when starting a new codespace or restarting an existing one.

Run the following command from the codespace terminal:

./gitlab/bootstrap/setup.sh
After some time, a pop-up box should appear with a link to the URL for your GitLab server.

You can also access the URL by going to the Ports tab in your terminal. Right-click the URL listed under the Local Address and click the Open in Browser tab.

Open the GitLab server in your browser and use the following credentials to authenticate:

Username: root
Password: actions-importer-labs!
Once authenticated, you should see a GitLab server with a few predefined pipelines in the actions-importer group.

Labs for GitLab
Perform the following labs to learn more about Actions migrations with GitHub Actions Importer:

Configure credentials for GitHub Actions Importer
Perform an audit on GitLab pipelines
Forecast potential build runner usage
Perform a dry-run migration of a GitLab pipeline
Use custom transformers to customize GitHub Actions Importer's behavior
Perform a production migration of a GitLab pipeline
Troubleshoot the GitHub Actions Importer CLI
The CLI extension for GitHub Actions Importer can be manually installed by following these steps:

Verify you are in the codespace terminal

Run this command from within the codespace terminal:

gh extension install github/gh-actions-importer
Verify the result of the install contains:

$ gh extension install github/gh-actions-importer
âœ“ Installed extension github/gh-actions-importer
Verify GitHub Actions Importer CLI extension is installed and working by running the following command from the codespace terminal:

gh actions-importer version
**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.https://github.com/bradford80USA/unamed/actions/workflows/azure-container-webapp.yml1998350Program Overview
Privileges of Membership
Over 1300 organizations and individuals parti-
cipate in the JCP program. While there are no
obligatory duties, members have the opportunity
to influence the evolution of Java technology
through the development of Java Specification
Requests (JSR).
Members can license their Java specifications
under a variety of licenses, including open source
options. Anyone must be able to create an indepen-
dent implementation as long as they license and pass the
TCK to ensure compatibility. Members must also
make the option available to license the TCK and
RI separately. In addition, individuals, educational
organizations, and qualified nonprofits must have
access to the TCKs free of charge.
Successful Members:
â€¢ Review proposed JSRs and drafts
â€¢ Submit JSRs
â€¢ Nominate themselves or others to serve
on Expert Groups, which create or revise
specifications
â€¢ Build independent implementations
â€¢ Vote on EC membership ballots
â€¢ Nominate themselves for an EC seat
Members of an Expert Group may also:
â€¢ Serve as the Specification Lead of an
Expert Group
â€¢ Select others to join their Expert Group
â€¢ Use feedback from members and the public
to improve the quality of a specification
â€¢ Complete a specification, its RI, and its
associated TCK
â€¢ Maintain a specification after it is written
How to Become a Member
A person or organization can become a member
by signing the Java Specification Participation
Agreement (JSPA). This agreement between an
organization or individual and Oracle establishes
each memberâ€™s rights and obligations when partici-
pating in the JCP program. To cover costs, the JSPA
charges a nominal fee for commercial entities, but it
is free for Java User Groups and individuals.
The Java Specification Review Process
Currently, over 350 JSRs are in development.
A specification follows four major steps as it
progresses through the process, as shown in
the timeline.
1. INITIATION: A specification is initiated by one or
more members and approved for development
by the Executive Committee.
2. EARLY DRAFT: A group of experts is formed to
draft the specification for the public, community
and the Executive Committee to review. The
Expert Group uses feedback from the review to
revise the specification.
3. PUBLIC DRAFT: The draft is posted on the Internet
for a second review by the public. The Expert
Group uses the feedback to refine the document.
The Executive Committee decides if the draft
should proceed to the next step. The Specification
Lead ensures that the RI and its associated TCK
are completed before sending the specification to
the Executive Committee for final approval.
Java Community * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.providers.downloads;
import android.app.AppOpsManager;
import android.app.DownloadManager;
import android.app.DownloadManager.Request;
import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.UriMatcher;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.database.Cursor;
import android.database.DatabaseUtils;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.net.Uri;
import android.os.Binder;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.ParcelFileDescriptor;
import android.os.ParcelFileDescriptor.OnCloseListener;
import android.os.Process;
import android.provider.BaseColumns;
import android.provider.Downloads;
import android.provider.OpenableColumns;
import android.text.TextUtils;
import android.text.format.DateUtils;
import android.util.Log;
import libcore.io.IoUtils;
import com.android.internal.util.IndentingPrintWriter;
import com.google.android.collect.Maps;
import com.google.common.annotations.VisibleForTesting;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
/**
 * Allows application to interact with the download manager.
 */
public final class DownloadProvider extends ContentProvider {
    /** Database filename */
    private static final String DB_NAME = "downloads.db";
    /** Current database version */
    private static final int DB_VERSION = 109;
    /** Name of table in the database */
    private static final String DB_TABLE = "downloads";
    /** MIME type for the entire download list */
    private static final String DOWNLOAD_LIST_TYPE = "vnd.android.cursor.dir/download";
    /** MIME type for an individual download */
    private static final String DOWNLOAD_TYPE = "vnd.android.cursor.item/download";
    /** URI matcher used to recognize URIs sent by applications */
    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    /** URI matcher constant for the URI of all downloads belonging to the calling UID */
    private static final int MY_DOWNLOADS = 1;
    /** URI matcher constant for the URI of an individual download belonging to the calling UID */
    private static final int MY_DOWNLOADS_ID = 2;
    /** URI matcher constant for the URI of all downloads in the system */
    private static final int ALL_DOWNLOADS = 3;
    /** URI matcher constant for the URI of an individual download */
    private static final int ALL_DOWNLOADS_ID = 4;
    /** URI matcher constant for the URI of a download's request headers */
    private static final int REQUEST_HEADERS_URI = 5;
    /** URI matcher constant for the public URI returned by
     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file
     * is publicly accessible.
     */
    private static final int PUBLIC_DOWNLOAD_ID = 6;
    static {
        sURIMatcher.addURI("downloads", "my_downloads", MY_DOWNLOADS);
        sURIMatcher.addURI("downloads", "my_downloads/#", MY_DOWNLOADS_ID);
        sURIMatcher.addURI("downloads", "all_downloads", ALL_DOWNLOADS);
        sURIMatcher.addURI("downloads", "all_downloads/#", ALL_DOWNLOADS_ID);
        sURIMatcher.addURI("downloads",
                "my_downloads/#/" + Downloads.Impl.RequestHeaders.URI_SEGMENT,
                REQUEST_HEADERS_URI);
        sURIMatcher.addURI("downloads",
                "all_downloads/#/" + Downloads.Impl.RequestHeaders.URI_SEGMENT,
                REQUEST_HEADERS_URI);
        // temporary, for backwards compatibility
        sURIMatcher.addURI("downloads", "download", MY_DOWNLOADS);
        sURIMatcher.addURI("downloads", "download/#", MY_DOWNLOADS_ID);
        sURIMatcher.addURI("downloads",
                "download/#/" + Downloads.Impl.RequestHeaders.URI_SEGMENT,
                REQUEST_HEADERS_URI);
        sURIMatcher.addURI("downloads",
                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + "/#",
                PUBLIC_DOWNLOAD_ID);
    }
    /** Different base URIs that could be used to access an individual download */
    private static final Uri[] BASE_URIS = new Uri[] {
            Downloads.Impl.CONTENT_URI,
            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,
    };
    private static final String[] sAppReadableColumnsArray = new String[] {
        Downloads.Impl._ID,
        Downloads.Impl.COLUMN_APP_DATA,
        Downloads.Impl._DATA,
        Downloads.Impl.COLUMN_MIME_TYPE,
        Downloads.Impl.COLUMN_VISIBILITY,
        Downloads.Impl.COLUMN_DESTINATION,
        Downloads.Impl.COLUMN_CONTROL,
        Downloads.Impl.COLUMN_STATUS,
        Downloads.Impl.COLUMN_LAST_MODIFICATION,
        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,
        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,
        Downloads.Impl.COLUMN_TOTAL_BYTES,
        Downloads.Impl.COLUMN_CURRENT_BYTES,
        Downloads.Impl.COLUMN_TITLE,
        Downloads.Impl.COLUMN_DESCRIPTION,
        Downloads.Impl.COLUMN_URI,
        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,
        Downloads.Impl.COLUMN_FILE_NAME_HINT,
        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,
        Downloads.Impl.COLUMN_DELETED,
        OpenableColumns.DISPLAY_NAME,
        OpenableColumns.SIZE,
    };
    private static final HashSet<String> sAppReadableColumnsSet;
    private static final HashMap<String, String> sColumnsMap;
    static {
        sAppReadableColumnsSet = new HashSet<String>();
        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {
            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);
        }
        sColumnsMap = Maps.newHashMap();
        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,
                Downloads.Impl.COLUMN_TITLE + " AS " + OpenableColumns.DISPLAY_NAME);
        sColumnsMap.put(OpenableColumns.SIZE,
                Downloads.Impl.COLUMN_TOTAL_BYTES + " AS " + OpenableColumns.SIZE);
    }
    private static final List<String> downloadManagerColumnsList =
            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);
    private Handler mHandler;
    /** The database that lies underneath this content provider */
    private SQLiteOpenHelper mOpenHelper = null;
    /** List of uids that can access the downloads */
    private int mSystemUid = -1;
    private int mDefContainerUid = -1;
    @VisibleForTesting
    SystemFacade mSystemFacade;
    /**
     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for
     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})
     * to return both pieces of information, and provides some utility logic to ease piece-by-piece
     * construction of selections.
     */
    private static class SqlSelection {
        public StringBuilder mWhereClause = new StringBuilder();
        public List<String> mParameters = new ArrayList<String>();
        public <T> void appendClause(String newClause, final T... parameters) {
            if (newClause == null || newClause.isEmpty()) {
                return;
            }
            if (mWhereClause.length() != 0) {
                mWhereClause.append(" AND ");
            }
            mWhereClause.append("(");
            mWhereClause.append(newClause);
            mWhereClause.append(")");
            if (parameters != null) {
                for (Object parameter : parameters) {
                    mParameters.add(parameter.toString());
                }
            }
        }
        public String getSelection() {
            return mWhereClause.toString();
        }
        public String[] getParameters() {
            String[] array = new String[mParameters.size()];
            return mParameters.toArray(array);
        }
    }
    /**
     * Creates and updated database on demand when opening it.
     * Helper class to create database the first time the provider is
     * initialized and upgrade it when a new version of the provider needs
     * an updated version of the database.
     */
    private final class DatabaseHelper extends SQLiteOpenHelper {
        public DatabaseHelper(final Context context) {
            super(context, DB_NAME, null, DB_VERSION);
        }
        /**
         * Creates database the first time we try to open it.
         */
        @Override
        public void onCreate(final SQLiteDatabase db) {
            if (Constants.LOGVV) {
                Log.v(Constants.TAG, "populating new database");
            }
            onUpgrade(db, 0, DB_VERSION);
        }
        /**
         * Updates the database format when a content provider is used
         * with a database that was created with a different format.
         *
         * Note: to support downgrades, creating a table should always drop it first if it already
         * exists.
         */
        @Override
        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {
            if (oldV == 31) {
                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the
                // same as upgrading from 100.
                oldV = 100;
            } else if (oldV < 100) {
                // no logic to upgrade from these older version, just recreate the DB
                Log.i(Constants.TAG, "Upgrading downloads database from version " + oldV
                      + " to version " + newV + ", which will destroy all old data");
                oldV = 99;
            } else if (oldV > newV) {
                // user must have downgraded software; we have no way to know how to downgrade the
                // DB, so just recreate it
                Log.i(Constants.TAG, "Downgrading downloads database from version " + oldV
                      + " (current version is " + newV + "), destroying all old data");
                oldV = 99;
            }
            for (int version = oldV + 1; version <= newV; version++) {
                upgradeTo(db, version);
            }
        }
        /**
         * Upgrade database from (version - 1) to version.
         */
        private void upgradeTo(SQLiteDatabase db, int version) {
            switch (version) {
                case 100:
                    createDownloadsTable(db);
                    break;
                case 101:
                    createHeadersTable(db);
                    break;
                case 102:
                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,
                              "INTEGER NOT NULL DEFAULT 0");
                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,
                              "INTEGER NOT NULL DEFAkingdom hearts  Process Program Overview
The Java Community Process (JCP) program is the formalization of the open, inclusive
process that has been used since 1998 to develop and revise Java technology specifications,
reference implementations (RI), and technology compatibility kits (TCK). Jav1300https://github.com/bradford80USA/unamed/actions/workflows/azure-container-webapp.yml1998350Program13001998350
1.1001111000110111...1.9E3779B97F4A7C 10 5...gold